{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 7b630cd11700d0cd6a09","webpack:///./src/maggaMediator.js","webpack:///./plugins/simple.js","webpack:///./src/message.js","webpack:///./plugins/monitoring.js","webpack:///./src/hooks.js","webpack:///./~/events/events.js","webpack:///./src/plugin/plugin.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA,qBAAoB,yDAAyD;AAC7E,yBAAwB,qCAAqC;AAC7D;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,cAAc;AACzB,gBAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnIA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,qCAAoC;AACpC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kCAAiC;AACjC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,0DAAyD;AACzD,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,G;;;;;;ACjBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACzSA;AACA;AACA,aAAY,OAAO;AACnB,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"maggaMediator.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jmM\"] = factory();\n\telse\n\t\troot[\"jmM\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7b630cd11700d0cd6a09\n **/","var simplePlugin = require('../plugins/simple.js'),\n    monitoringPlugin = require('../plugins/monitoring.js');\n\nvar DEFAULT_CONFIG = {\n    plugins: [simplePlugin, monitoringPlugin]\n    // ,external: [{\"transport\":\"socks\",\"address\":\"localhost\",\"port\":\"99999\"}]\n    // \"plugins.socks: {\"address\":\"localhost\",\"port\":\"99999\"}\"\n};\n\n\nvar hooks = require('./hooks.js');\nvar Message = require('./message.js');\n\nfunction MaggaMediator(configObj) {\n    // Mediator.apply(this,arguments);\n    this._config = {};\n    this.config(configObj || DEFAULT_CONFIG);\n    this.init();\n}\n\n/**\n * Plugin API to register a plugin on the mediator\n * @type {[type]}\n */\nMaggaMediator.prototype.plugin = require('./plugin/plugin.js');\n// MaggaMediator.prototype._loadPlugins = require('./plugin/loadPlugins.js');\n\nMaggaMediator.prototype.init = function () {\n    var self = this;\n    var config = self._config;\n    hooks.init(self);\n    if (typeof config.plugins !== 'undefined') {\n        // self._loadPlugins(config.plugins);\n        config.plugins.forEach(function (plugin) {\n            self.plugin(plugin);\n        });\n    }\n//    if (typeof config.loadPlugins !== 'undefined') {\n//        self._loadPlugins(config.loadPlugins);\n//    }\n};\n\nMaggaMediator.prototype._dispatchAction = function (action, eventName, data) {\n    var self = this;\n    if (self._hasDispatcher) {\n        self.emit('dispatch', action, eventName, function (resolvedEventName) {\n            self.emit(action, resolvedEventName, data);\n        });\n    } else {\n        self.emit(action, eventName, data);\n    }\n};\n\n\n/**\n * Subscribe \"subscriber\" to a event using a callback\n * @param {string} eventName - the event name\n * @param {function} cb - the callback function\n * @returns {void}\n */\nMaggaMediator.prototype.subscribe = function (eventName, cb) {\n    if (typeof eventName !== 'string') {\n        throw new Error('[MaggaMediator.subscribe] event name must be string');\n    }\n    if (typeof cb !== 'function') {\n        throw new Error('[MaggaMediator.subscribe] Second argument must be a function');\n    }\n    this._dispatchAction('subscribe', eventName, cb);\n};\n\n/**\n * Unsubscribe \"cb\" from a event\n * @param {string} eventName - the event name\n * @param {string} cb - the cb\n * @returns {void}\n */\nMaggaMediator.prototype.unsubscribe = function (eventName, cb) {\n    if (typeof eventName !== 'string') {\n        throw new Error('[MaggaMediator.subscribe] event name must be string');\n    }\n    if (typeof cb !== 'function') {\n        throw new Error('[MaggaMediator.subscribe] Second argument must be a function');\n    }\n\n    this._dispatchAction('unsubscribe', eventName, cb);\n};\n\n/**\n * Publish a value to a event\n * @param {string} eventName - the event name\n * @param {object} value - a value of any type\n * @returns {void}\n */\nMaggaMediator.prototype.publish = function (eventName, value) {\n    var self = this,\n        data;\n    if (typeof eventName !== 'string') {\n        throw new Error('Event name must be string');\n    }\n    if (!(value instanceof Message)) {\n        data = new Message(value);\n    } else {\n        data = value;\n    }\n    self._dispatchAction('publish', eventName, data);\n};\n\n/**\n * Extend MaggaMediator with config function.\n * MaggaMediator.config() gives current config, calling with object will update it\n * @param {object | void} configObj - configuration object\n * @returns {{}|*} will return current configuration of the Mediator\n */\nMaggaMediator.prototype.config = function (configObj) {\n    var key, result;\n    if (arguments.length === 0) {\n        result = this._config;\n    } else {\n        if (typeof configObj !== 'object' || !(configObj instanceof Object)) {\n            throw new Error('Configuration must be an Object');\n        }\n        for (key in configObj) {\n            if (Object.prototype.hasOwnProperty.call(configObj, key)) {\n                this._config[key] = configObj[key];\n            }\n        }\n        result = this._config;\n    }\n    return result;\n};\n\nmodule.exports = MaggaMediator;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/maggaMediator.js\n ** module id = 0\n ** module chunks = 0\n **/","var Message = require('../src/message.js');\nmodule.exports = {\n\n    init: function (mediator) {\n        if (typeof mediator._innerTransport === 'undefined') {\n            mediator._innerTransport = {};\n        }\n    },\n    subscribe: function (eventName, cb) {\n        var self = this;\n        var transport = this._innerTransport;\n\n        // If we have this event then subscribe\n        if (typeof transport[eventName] !== 'undefined') {\n            transport[eventName].subscribers.push(cb);\n        } else {\n            // create new event\n            transport[eventName] = {subscribers: [cb]};\n            self.emit('addChannel', eventName);\n        }\n        return transport[eventName];\n    },\n    unsubscribe: function (eventName, cb) {\n        var self = this,\n            transport = this._innerTransport,\n            subscribers, idxOf;\n\n        if (typeof transport[eventName] !== 'undefined'\n            && typeof transport[eventName].subscribers !== 'undefined') {\n            // delete cb from subscribers\n            subscribers = transport[eventName].subscribers;\n            idxOf = subscribers.indexOf(cb);\n            while (idxOf !== -1) {\n                subscribers.splice(idxOf, 1);\n                idxOf = subscribers.indexOf(cb);\n            }\n            // delete channel if no subscribers\n            if (subscribers.length === 0) {\n                delete transport[eventName];\n                self.emit('deleteChannel', eventName);\n            }\n        }\n    },\n    publish: function (eventName, value) {\n        var transport = this._innerTransport,\n            subscribers;\n\n        if (typeof transport[eventName] === 'undefined') {\n//            console.warn(\"No subscribers for this publish\");\n//            self[eventName] = {\"subscribers\": []};\n        } else {\n            subscribers = transport[eventName].subscribers;\n            // Check if subscribers is an Array\n            if (Object.prototype.toString.call(subscribers) !== '[object Array]') {\n                throw new Error('Subscribers property of event mast be an Array.');\n            }\n            // IE: 9+\n            subscribers.forEach(function (cb) {\n                if (typeof cb !== 'function') {\n                    throw new Error('Subscriber is not a function.');\n                }\n                if (value instanceof Message) {\n                    cb.call(transport, value.getData());\n                }\n            });\n        }\n    }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./plugins/simple.js\n ** module id = 1\n ** module chunks = 0 1\n **/","// TODO Implement Message data envelope in a right way\n\nfunction Message(data) {\n    // We use _md = 1 in data to understand i\n    if (typeof data === 'object' && data._u === 1) {\n        this._data = data._data;\n        this._context = data._context;\n    } else {\n        this._data = data;\n        this._context = {};\n    }\n    this._u = 1;\n}\n\nMessage.prototype.getData = function () {\n    return this._data;\n};\n\nMessage.prototype.getContext = function (contextKey) {\n    return this._context[contextKey];\n};\n\nMessage.prototype.setContext = function (contextKey, value) {\n    this._context[contextKey] = value;\n};\n\nmodule.exports = Message;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/message.js\n ** module id = 2\n ** module chunks = 0 1\n **/","// TODO: Functionality for monitoring. In progress.\n// for monitoring inspiration take a look at\n// https://github.com/yourdelivery/JigMagga/blob/\n// 922709fe80635d5180160bbac6271ea86bd029cf/core/mediator/mediator.js\n// with plugins for internal communications maybe we could get rid of it\nmodule.exports = {\n    init: function () {\n    },\n    subscribe: function (eventName, cb) {\n        console.log('Monitor subscribe ', eventName, cb);  // If we have this event then subscribe\n    },\n    unsubscribe: function (eventName, cb) {\n        console.log('Monitor unsubscribe ', eventName, cb);\n    },\n    publish: function (eventName, value) {\n        console.log('Monitor publish ', eventName, value);\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./plugins/monitoring.js\n ** module id = 3\n ** module chunks = 0 1\n **/","var EventEmitter = require('events').EventEmitter;\n\nmodule.exports = {\n    init: function (mediator) {\n        mediator._eventEmitter = new EventEmitter();\n        mediator.on = mediator._eventEmitter.on;\n        mediator.off = mediator._eventEmitter.removeListener;\n        mediator.once = mediator._eventEmitter.once;\n        mediator.emit = mediator._eventEmitter.emit;\n    }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/hooks.js\n ** module id = 4\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * Plugin API to register a plugin\n * @param  {[type]} plugin [pass a custom plugin]\n * @returns {void}\n */\nmodule.exports = function (plugin) {\n    if (typeof plugin.init === 'function') {\n        plugin.init(this);\n    }\n\n    if (typeof plugin.publish === 'function') {\n        this.on('publish', plugin.publish);\n    }\n\n    if (typeof plugin.subscribe === 'function') {\n        this.on('subscribe', plugin.subscribe);\n    }\n\n    if (typeof plugin.unsubscribe === 'function') {\n        this.on('unsubscribe', plugin.unsubscribe);\n    }\n\n    if (typeof plugin.error === 'function') {\n        this.on('error', plugin.error);\n    }\n\n    if (typeof plugin.warning === 'function') {\n        this.on('warning', plugin.warning);\n    }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plugin/plugin.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}